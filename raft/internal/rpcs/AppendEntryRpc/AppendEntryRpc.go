package AppendEntryRpc

import (
	"fmt"
	"log"
	"raft/internal/node/nodeState"
	"raft/internal/raftstate"
	"raft/internal/rpcs"
	app_resp "raft/internal/rpcs/AppendResponse"
	"raft/pkg/rpcEncoding/out/protobuf"
	"strconv"

	"google.golang.org/protobuf/proto"
)

type AppendEntryRpc struct {
	pMex protobuf.AppendEntriesRequest
}

func GenerateHearthbeat(state raftstate.State) rpcs.Rpc {
	var entries []*protobuf.LogEntry = state.GetEntries()
	prevLogIndex := len(entries) - 1
	var prevLogTerm uint64 = 0
	if prevLogIndex > 0 {
		prevLogTerm = entries[prevLogIndex].GetTerm()
	}

	var app = &AppendEntryRpc{
		pMex: protobuf.AppendEntriesRequest{
			Term:         state.GetTerm(),
			LeaderId:     state.GetId(),
			PrevLogIndex: uint64(prevLogIndex),
			PrevLogTerm:  prevLogTerm,
			Entries:      make([]*protobuf.LogEntry, 0),
			LeaderCommit: state.GetCommitIndex(),
		},
	}

//	log.Print("hearthbit generated by ", state.GetId(), " : ", app.ToString())

	return app
}

func NewAppendEntryRPC(term uint64, leaderId string, prevLogIndex uint64,
	prevLogTerm uint64, entries []*protobuf.LogEntry,
	leaderCommit int64) rpcs.Rpc {
	return &AppendEntryRpc{
		pMex: protobuf.AppendEntriesRequest{
			Term:         term,
			LeaderId:     leaderId,
			PrevLogIndex: prevLogIndex,
			PrevLogTerm:  prevLogTerm,
			Entries:      entries,
			LeaderCommit: leaderCommit,
		},
	}
}

func checkConsistency(prevLogIndex uint64, prevLogTerm uint64, entries []*protobuf.LogEntry) (bool, int) {
  //fmt.Println("------", entries)
  var logSize = len(entries)  
  if logSize == 0 {
    fmt.Print("case 1")
        return true, 1 
    }
  if logSize-1 < int(prevLogIndex) {
    fmt.Print("case 2")
    return false, (logSize - 1)
  }
    fmt.Print("case 3")
	return (entries[prevLogIndex].GetTerm() == prevLogTerm), int(prevLogIndex)
}

// Manage implements rpcs.Rpc.
func (this *AppendEntryRpc) Execute(state *raftstate.State, senderState *nodeState.VolatileNodeState) *rpcs.Rpc {

	var role raftstate.Role = (*state).GetRole()
	var id string = (*state).GetId()
	var myTerm uint64 = (*state).GetTerm()
	var error int
  var consistent bool
	var success bool
	var prevLogIndex uint64 = this.pMex.GetPrevLogIndex()
	var prevLogTerm uint64 = this.pMex.GetPrevLogTerm()
	var entries []*protobuf.LogEntry = (*state).GetEntries()
  var newEntries = this.pMex.GetEntries()

  if len(newEntries) == 0 {
    log.Println("heartbit")
  } else {
    log.Println("received Append Entry", newEntries)
  }

  consistent, error = checkConsistency(prevLogIndex, prevLogTerm, entries)
  fmt.Println(!consistent)

	if role != raftstate.FOLLOWER {
		(*state).BecomeFollower()
	}

	if this.pMex.GetTerm() < myTerm {
		success = false
		return respondeAppend(id, success, myTerm, -1)
	} else if !consistent {
    fmt.Println("Not consistent")
		success = false
		return respondeAppend(id, success, myTerm, int(error))
	} else {
		(*state).AppendEntries(newEntries, int(prevLogIndex))
		success = true
		var leaderCommit int64 = this.pMex.GetLeaderCommit()
		var lastNewEntryIdx int64 = int64(len(entries) - 1)
		if leaderCommit > (*state).GetCommitIndex() {
			if leaderCommit > lastNewEntryIdx {
				(*state).SetCommitIndex(lastNewEntryIdx)
			} else {
				(*state).SetCommitIndex(leaderCommit)
			}
		}
		return respondeAppend(id, success, myTerm, -1)

	}
}

func respondeAppend(id string, success bool, term uint64, error int) *rpcs.Rpc {
	var appendEntryResp rpcs.Rpc = app_resp.NewAppendResponseRPC(
		id,
		success,
		term,
		error)
	return &appendEntryResp
}

// ToString implements rpcs.Rpc.
func (this *AppendEntryRpc) ToString() string {
	var entries string
	for _, el := range this.pMex.Entries {
		entries += el.String()
	}
	return "{term : " + strconv.Itoa(int(this.pMex.GetTerm())) + ", leaderId: " + this.pMex.GetLeaderId() + ", prevLogIndex: " + strconv.Itoa(int(this.pMex.PrevLogIndex)) + ", prevLogTerm: " + strconv.Itoa(int(this.pMex.PrevLogIndex)) + ", entries: " + entries + ", leaderCommit: " + strconv.Itoa(int(this.pMex.LeaderCommit)) + "}"
}

func (this *AppendEntryRpc) Encode() ([]byte, error) {

	var mess []byte
	var err error
	mess, err = proto.Marshal(&(*this).pMex)
    if err != nil {
        log.Panicln("error in Encoding Append Entry: ", err)
    }
	return mess, err
}

func (this *AppendEntryRpc) Decode(rawMex []byte) (error) {
	err := proto.Unmarshal(rawMex, &this.pMex)
    if err != nil {
        log.Panicln("error in Decoding Append Entry: ", err)
    }
	return err
}


/* testing */
func DummyAppendEntry(state raftstate.State, index int) rpcs.Rpc {
  log.Printf("index: %d, len: %d",index, len(state.GetEntries()))
  var entries []*protobuf.LogEntry = state.GetEntries()
  //log.Println("entries: ", entries[index])
  if index != 0 {
      entries = entries[index:]
  }
	prevLogIndex := index - 1
	var prevLogTerm uint64 = 0
	if prevLogIndex >= 0 {
		prevLogTerm = entries[prevLogIndex].GetTerm()
	} else {
    prevLogIndex = 0
  }

	var app = &AppendEntryRpc{
		pMex: protobuf.AppendEntriesRequest{
			Term:         state.GetTerm(),
			LeaderId:     state.GetId(),
			PrevLogIndex: uint64(prevLogIndex),
			PrevLogTerm:  prevLogTerm,
      Entries:      entries,
			LeaderCommit: state.GetCommitIndex(),
		},
	}
  //log.Println(app.pMex.String())
	return app

}
