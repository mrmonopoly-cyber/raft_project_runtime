package AppendEntryRpc

import (
    "fmt"
    "log"
    "raft/internal/node/nodeState"
    "raft/internal/raftstate"
    "raft/internal/rpcs"
    app_resp "raft/internal/rpcs/AppendResponse"
    "raft/pkg/rpcEncoding/out/protobuf"
    "strconv"

    "google.golang.org/protobuf/proto"
)

type AppendEntryRpc struct {
    pMex protobuf.AppendEntriesRequest
}

func GenerateHearthbeat(state raftstate.State) rpcs.Rpc {
    var entries []*protobuf.LogEntry = state.GetEntries()
    prevLogIndex := len(entries) - 1
    var prevLogTerm uint64 = 0
    if prevLogIndex > 0 {
        prevLogTerm = entries[prevLogIndex].GetTerm()
    }

    var app = &AppendEntryRpc{
        pMex: protobuf.AppendEntriesRequest{
            Term:         state.GetTerm(),
            LeaderId:     state.GetId(),
            PrevLogIndex: int64(prevLogIndex),
            PrevLogTerm:  prevLogTerm,
            Entries:      make([]*protobuf.LogEntry, 0),
            LeaderCommit: state.GetCommitIndex(),
        },
    }

    //	log.Print("hearthbit generated by ", state.GetId(), " : ", app.ToString())

    return app
}

func NewAppendEntryRPC(term uint64, leaderId string, prevLogIndex int64,
prevLogTerm uint64, entries []*protobuf.LogEntry,
leaderCommit int64) rpcs.Rpc {
    return &AppendEntryRpc{
        pMex: protobuf.AppendEntriesRequest{
            Term:         term,
            LeaderId:     leaderId,
            PrevLogIndex: prevLogIndex,
            PrevLogTerm:  prevLogTerm,
            Entries:      entries,
            LeaderCommit: leaderCommit,
        },
    }
}

func checkConsistency(prevLogIndex int64, prevLogTerm uint64, entries []*protobuf.LogEntry) (bool, int) {
    var logSize = len(entries)
    if prevLogIndex == -1 {
        return true, 0
    }

    if logSize == 0 {
        log.Println("case 2: logSize = 0")
        return false, 0
    }

    if logSize-1 < int(prevLogIndex) {
        log.Println("case 2")
        log.Printf("logSize - 1: %d, and prevLogIndex: %d", (logSize-1), int(prevLogIndex))
        return false, (logSize - 1)
    }
    fmt.Print("case 3")
    return (entries[prevLogIndex].GetTerm() == prevLogTerm), int(prevLogIndex)
}

// Manage implements rpcs.Rpc.
func (this *AppendEntryRpc) Execute(state *raftstate.State, senderState *nodeState.VolatileNodeState) *rpcs.Rpc {

    (*state).StopElectionTimeout()
    var role raftstate.Role = (*state).GetRole()
    var id string = (*state).GetId()
    var myTerm uint64 = (*state).GetTerm()
    var error int
    var consistent bool
    var success bool
    var prevLogIndex int64 = this.pMex.GetPrevLogIndex()
    var prevLogTerm uint64 = this.pMex.GetPrevLogTerm()
    var entries []*protobuf.LogEntry = (*state).GetEntries()
    var newEntries []*protobuf.LogEntry = this.pMex.GetEntries()
    var resp *rpcs.Rpc = nil

    if role != raftstate.FOLLOWER {
        (*state).BecomeFollower()
    }

    if this.pMex.GetTerm() < myTerm {
        (*state).StartElectionTimeout()
        return respondeAppend(id, false, myTerm, -1)
    }

    if len(newEntries) > 0 {
        log.Println("received Append Entry", newEntries)
        consistent, error = checkConsistency(prevLogIndex, prevLogTerm, entries)
        fmt.Println(!consistent)

        if !consistent {
            fmt.Println("Not consistent")
            resp = respondeAppend(id, false, myTerm, int(error))
        } else {
            (*state).AppendEntries(newEntries, int(prevLogIndex))
            var leaderCommit int64 = this.pMex.GetLeaderCommit()
            var lastNewEntryIdx int64 = int64(len(entries) - 1)
            if leaderCommit > (*state).GetCommitIndex() {
                if leaderCommit > lastNewEntryIdx {
                    (*state).SetCommitIndex(lastNewEntryIdx)
                } else {
                    (*state).SetCommitIndex(leaderCommit)
                }
            }
            resp = respondeAppend(id, true , myTerm, -1)

        }
    } else {
        log.Println("hearthbeat")
        success = true

        resp = respondeAppend(id, success, myTerm, -1)
    }
    (*state).StartElectionTimeout()
    return resp
}

func respondeAppend(id string, success bool, term uint64, error int) *rpcs.Rpc {
    var appendEntryResp rpcs.Rpc = app_resp.NewAppendResponseRPC(
        id,
        success,
        term,
        error)
        return &appendEntryResp
    }

    // ToString implements rpcs.Rpc.
    func (this *AppendEntryRpc) ToString() string {
        var entries string
        for _, el := range this.pMex.Entries {
            entries += el.String()
        }
        return "{term : " + strconv.Itoa(int(this.pMex.GetTerm())) + ", leaderId: " + this.pMex.GetLeaderId() + ", prevLogIndex: " + strconv.Itoa(int(this.pMex.PrevLogIndex)) + ", prevLogTerm: " + strconv.Itoa(int(this.pMex.PrevLogIndex)) + ", entries: " + entries + ", leaderCommit: " + strconv.Itoa(int(this.pMex.LeaderCommit)) + "}"
    }

    func (this *AppendEntryRpc) Encode() ([]byte, error) {

        var mess []byte
        var err error
        mess, err = proto.Marshal(&(*this).pMex)
        if err != nil {
            log.Panicln("error in Encoding Append Entry: ", err)
        }
        return mess, err
    }

    func (this *AppendEntryRpc) Decode(rawMex []byte) error {
        err := proto.Unmarshal(rawMex, &this.pMex)
        if err != nil {
            log.Panicln("error in Decoding Append Entry: ", err)
        }
        return err
    }

    /* testing */
    func DummyAppendEntry(state raftstate.State, index int) rpcs.Rpc {
        var entries []*protobuf.LogEntry = state.GetEntries()
        //log.Println("entries: ", entries[index])
        var enToApp []*protobuf.LogEntry
        if index != 0 {
            enToApp = entries[index:]
        } else {
            enToApp = entries[:]
        }
        log.Printf("index: %d, len: %d", index, len(state.GetEntries()))
        log.Println("entries: ", entries)
        prevLogIndex := index - 1
        var prevLogTerm uint64 = 0
        if prevLogIndex >= 0 {
            prevLogTerm = entries[prevLogIndex].GetTerm()
        }

        var app = &AppendEntryRpc{
            pMex: protobuf.AppendEntriesRequest{
                Term:         state.GetTerm(),
                LeaderId:     state.GetId(),
                PrevLogIndex: int64(prevLogIndex),
                PrevLogTerm:  prevLogTerm,
                Entries:      enToApp,
                LeaderCommit: state.GetCommitIndex(),
            },
        }
        //log.Println(app.pMex.String())
        return app

    }
