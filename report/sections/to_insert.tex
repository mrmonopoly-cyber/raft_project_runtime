\subsubsection{File System abstraction}
Il cluster è progettato con l'obiettivo principale di fornire un file system distribuito. 
In questo contesto, abbiamo ritenuto indispensabile definire un livello di astrazione del file 
system per ogni nodo, al fine di facilitare l'interazione con esso e garantire un'implementazione 
più modulare e gestibile.\\
L'astrazione del file system di ciascun nodo rappresenta un'interfaccia standardizzata che consente di eseguire operazioni sui 
file in modo uniforme, indipendentemente dalle specificità del nodo. Questo approccio consente di mantenere
un elevato grado di coerenza e semplicità nella gestione del file system distribuito.
Il cuore dell'astrazione risiede in un singolo metodo principale, chiamato ApplyLogEntry, che svolge un ruolo centrale nell'elaborazione
delle operazioni sui file. Questo metodo è progettato per accettare una "log entry" come input e 
gestire le seguenti funzioni: il metodo analizza la log entry per identificare il tipo di operazione da eseguire: creazione 
di un nuovo file, scrittura su un file, rinomina di un file, eliminazione di un file; in seguito, procede con 
l'esecuzione dell'operazione corrispondente sul file system del nodo.

\subsubsection{Instaurazione connessione tra nodi}
All'avvio, il nodo lancia diverse goroutine: innanzitutto, si mette in ascolto di nuove connessioni 
su una porta e attende che gli venga comunicato la sua appartiane a una qualche configurazione.
Cio' puo' accadere in diversi modi:
\begin{itemize}
    \item il master instaura una connesione con il nodo seguente e gli invia un AppendEntry con la
    configurazione di riferimento. Il nodo diventa follower e applica l'AppendEntry ricevuta

    \item richiesta dall'amministratore di sistema: l'operatore invia un messaggio a quel nodo dove 
    gli specifica la configurazione di appartenenza. Quando cio' accade il nodo diventa master.
    Questa situazione si verifica solamente nella fase di creazione del server ed e' necessaria per 
    definire un primo master che dia il via al servizio.
\end{itemize}
Dopodichè rimane in ascolto di nuove connessioni e ogni volta che ne arriva una nuova, il nodo 
controlla l'indirizzo IP, lo distingue tra indirizzo "interno" ed "esterno" e lancia una goroutine 
per ciascuna di queste categorie e, infine, aspetta di ricevere messaggi da queste connessioni. \\
Per l'instaurazione delle connesioni, il nostro sistema fa uso di un modulo apposito, chiamato 
\texttt{Node}, che rappresenta un singolo nodo e la sua connessione di riferimento, ed espone i 
metodi per comunicare con esso (invio e ricezione) e gestire la connesione (chiusura e aggiunta).

\subsubsection{Migliorie}
\begin{itemize}
    \item Ecosistema di test: Sviluppare una infrastruttura di test che permetta una validazione 
        software accurata e mirata trammite test automatici. Non e' stato sviluppato a causa della
        complessita' di sviluppare una architettura di test per una codice altamente asincrono e
        parallelo come il nostro
    \item Interfaccia funzionalita': Una interffaccia standardizzata per il plug and play di moduli
        i quali determinino le funzionalita' che il cluster offre in quel momento. L'ideale sarebbe
        nel permettere poi all'utente di utilizzare altri moduli per permettere al cluster di 
        compiere diverse mansioni non solo quella di filesystem.
    \item Eliminazione dei lock: in varie parti del codice sono presenti dei mutex per evitare 
        race condition. Questi sistemi non offrono una grande protezione contro le race condition 
        e risultano inoltre estremamente inefficenti. Eliminarli con l'idea di utilizzare 
        costrutti \textbf{lock free}, esempio stdatomic.h di C\/C\+\+, o di interamente rimuovere
        blocchi interamente sarebbe ottimale.
\end{itemize}
